/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Pantallas;

import Controlador.Conexion;
import Controlador.Variables;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import javax.swing.JOptionPane;
import java.util.ArrayList;
import java.util.concurrent.ExecutionException;
import javax.swing.ImageIcon;
import javax.swing.SwingWorker;

/**
 *
 * @author ALEJANDRO.DELGADILLO
 */
public class Inicio extends javax.swing.JFrame {
    
    //Definir el objeto para obtener la conexion con la base
    private Conexion conexion;
    
    //Almacenara la lista de las bases de datos
    private ArrayList<String> listaBasesDatos;
    //Almacenara la lista con las tablas de la base de datos
    private ArrayList<String> listaTablas;
    //Almacenara la lista con los campos de la tabla
    private ArrayList<String> listaCampos;
    
    //Alamcenara el usuario de logeo
    private String usuario;
    //Alamcenara el password de logeo
    private String password;
    
    //Almacenara el nombre de la base seleccionada
    private String base;
    //Almacenara el nombre de la tabla seleccionada
    private String tabla;
    
    //Variable que definira se existe la clave catastral en la tabla
    boolean existe_clave;
    String nombre_campo;
    
    /**
     * Creates new form Inicio
     */
    public Inicio() {
        initComponents();
    }
    public Inicio(ArrayList<String> listaBasesDatos, String usuario, String password){
        initComponents();
        
        //Asignar la lista de bases de datos a la variable global
        this.listaBasesDatos = listaBasesDatos;
        //Asignar el usuario a la variable global
        this.usuario = usuario;
        //Asignar el password a la variable global
        this.password = password;
        
        //Crear una nueva conexion
        conexion = new Conexion();
        //Asignar el usuario a la conexion
        conexion.setUsuario(usuario);
        //Asignar el password a la conexion
        conexion.setPassword(password);
        
        //Agregar las bases de datos al JList
        agregarLista();        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jScrollPane4 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList<>();
        jScrollPane5 = new javax.swing.JScrollPane();
        jList2 = new javax.swing.JList<>();
        jScrollPane6 = new javax.swing.JScrollPane();
        jList3 = new javax.swing.JList<>();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jButton5 = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem3 = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        jMenuItem2 = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setIconImage(new ImageIcon(getClass().getResource("/Imagenes/icono.png")).getImage());
        setResizable(false);

        jButton1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jButton1.setText("Aceptar");
        jButton1.setToolTipText("Pasar a ventana para generar clave cat");
        jButton1.setEnabled(false);
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jButton2.setText("Salir");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                jList1ValueChanged(evt);
            }
        });
        jScrollPane4.setViewportView(jList1);

        jList2.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                jList2ValueChanged(evt);
            }
        });
        jScrollPane5.setViewportView(jList2);

        jList3.setEnabled(false);
        jScrollPane6.setViewportView(jList3);

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel1.setText("Bases de Datos");

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel2.setText("Tablas");

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel3.setText("Campos");

        jButton5.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jButton5.setText("Restablecer");
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });

        jLabel4.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Imagenes/logo-inegi.png"))); // NOI18N

        jMenu1.setText("Opciones");

        jMenuItem1.setText("Cambiar Credenciales");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem1);

        jMenuItem3.setText("Restablecer");
        jMenuItem3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem3ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem3);
        jMenu1.add(jSeparator1);

        jMenuItem2.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F4, java.awt.event.InputEvent.ALT_MASK));
        jMenuItem2.setText("Salir");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem2);

        jMenuBar1.add(jMenu1);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel4)
                .addGap(104, 104, 104))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel2))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3)
                                    .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButton5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel4)
                .addGap(34, 34, 34)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel3)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jScrollPane6)
                    .addComponent(jScrollPane5, javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(50, 50, 50)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton5)
                    .addComponent(jButton1)
                    .addComponent(jButton2))
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    //Boton de aceptar
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        aceptar();
    }//GEN-LAST:event_jButton1ActionPerformed

    //Boton de salir
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        salir();
    }//GEN-LAST:event_jButton2ActionPerformed

    //Boton de restablecer
    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed
        restablecer();
    }//GEN-LAST:event_jButton5ActionPerformed
    
    //Cambio de estado del la lista de las bases de datos
    private void jList1ValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_jList1ValueChanged
        mostrarTablas();
    }//GEN-LAST:event_jList1ValueChanged

    //Cambio de estado de la lista de las tablas
    private void jList2ValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_jList2ValueChanged
        mostrarCampos();
    }//GEN-LAST:event_jList2ValueChanged

    //Item del menu para salir
    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        salir();
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    //Item del menu para cambiar credenciales
    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        cambiarCredenciales();
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    //Item del menu para restablecer
    private void jMenuItem3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem3ActionPerformed
        restablecer();
    }//GEN-LAST:event_jMenuItem3ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Inicio.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Inicio.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Inicio.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Inicio.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Inicio().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton5;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JList<String> jList1;
    private javax.swing.JList<String> jList2;
    private javax.swing.JList<String> jList3;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JMenuItem jMenuItem3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    // End of variables declaration//GEN-END:variables

    /***************************************************************************
     * METODOS PARA REALIZAR TAREAS ESPECIFICAS
     * *************************************************************************
     */
    
    /**
     * Usado por: Constructor
     * Definicion: Metodo que muestra las bases de datos en el JList correspondiente
     */
    private void agregarLista() {
        //Creamos un array de Strings con el tamaños de la lista con las bases de datos
        String[] listData = new String[listaBasesDatos.size()];
        //Pasar todos los valores de la lista al array
        for (int i = 0; i < listaBasesDatos.size(); i++) {
            //Obtenemos cada valor de la lista y lo asignamos al array en la misma posicion
            listData[i] = listaBasesDatos.get(i);
        }
        //Agregar el array al JList correspondiente
        jList1.setListData(listData);
    }
    
    /**
     * Usado por: JList1 el de Bases de Datos
     * Definicion: Metodo que muestra las tablas de la base seleccionada en el JList correspondiente
     */
    private void mostrarTablas(){
        //Obtener la base de datos seleccionada
        base = jList1.getSelectedValue();
        //Crear el objeto que almacenara las tablas de la base de datos seleccionada
        listaTablas = new ArrayList<String>();
        //Agregar la base de datos al objeto de la conexion
        conexion.setBase(base);
        //Definir la consulta para obtener las tablas
        String sql = "show tables";
        
        try {
            //Obtener la conexion y ejecutar la consulta
            Connection con = conexion.getConexion();
            Statement comando = con.createStatement();
            ResultSet registro = comando.executeQuery(sql);
            //Mientras el resultado tenga registros
            while (registro.next()){
                //Obtenemos el nombre de cada tabla
                String r = registro.getString("Tables_in_" + base);
                //En caso de que la tabla no sea respaldo
                if(r.indexOf(Variables.NAME_STRING_END_SUPPORT) == -1){
                    //Agregamos la tabla a la lista correspondiente
                    listaTablas.add(r);
                 }
            }
            //Obtenemos el array con los nombres de las tablas a partir de la lista
            String[] listData = cambiarArrayString(listaTablas);
            //Añadimos la informacion del array al JList para las tablas
            jList2.setListData(listData);
            
        //En caso de no ejecutar la consulta
        } catch (SQLException ex) {
            JOptionPane.showMessageDialog(
                    this, 
                    "Error al mostrar tablas\n" + ex.toString(), 
                    Variables.MSG_TITLE_ERROR_PADRON, 
                    JOptionPane.ERROR_MESSAGE
            );
        }
        //Deshabilitamos el boton de aceptar, en caso de que pase de mostrar campos a tablas
        jButton1.setEnabled(false);
        //Creamos un arreglo vacio para el JList de los campos
        String[] vacio = new String[0];
        //Asignamos el arreglo vacio al JList para borrar lo que tenga
        jList3.setListData(vacio);
        //Vaciamos la variable de tabla, para definir que aun no se elige ninguna
        tabla = "";
    }
    
    /**
     * Usado por: JList2 el de tablas
     * Definicion: Metodo que permite mostrar los campos de la tabla seleccionada en el JList correspondientee
     */
    private void mostrarCampos(){
        //Creamos la lista de los campos
        listaCampos = new ArrayList<String>();
        //En caso de que el nombre de la tabla no este vacio
        if(tabla != ""){
            //Obtener el nombre de la tabla seleccionada
            tabla = jList2.getSelectedValue();
            //En caso de que el nombre no sea nulo
            if(tabla != null){
                //Definimos la consulta para obtener los campos
                String sql = "describe " + tabla;
                try {
                    //Obtenermos la conexion y ejecutamos la consulta
                    Connection con = conexion.getConexion();
                    Statement comando = con.createStatement();
                    ResultSet registro = comando.executeQuery(sql);
                    //Mientras la consulta tenga registros
                    while (registro.next()){
                        //Obtenemos el nombre del campo
                        String r = registro.getString("Field");
                        //Asignamos el nombre a la lista de campos
                        listaCampos.add(r);
                    }
                    //Obtenemos el array a partir de la lista de campos
                    String[] listData = cambiarArrayString(listaCampos);
                    //Agregamos la informacion del array al JList
                    jList3.setListData(listData);
                    
                //En caso de que no se ejecute la consulta
                } catch (SQLException ex) {
                    JOptionPane.showMessageDialog(
                            this, 
                            "Error al mostrar campos\n" + ex.toString(), 
                            Variables.MSG_TITLE_ERROR_PADRON, 
                            JOptionPane.ERROR_MESSAGE
                    );
                }
            }
            
        //En caso de que el nombre de la tabla este vacio
        } else {
            //Asignar el valor de la tabla seleccionada, pues ya selecciono una base y mostro sus tablas
            tabla = jList2.getSelectedValue();
        }
        
        //En caso de que el nombre de la tabla indique que es un respaldo
        if(listaCampos.size() < 6 || tabla.indexOf(Variables.NAME_STRING_END_SUPPORT) != -1){
            //Deshabilitamos el boton de aceptar, pues no se puede trabajar con un respaldo
            jButton1.setEnabled(false); 
        } else {
            jButton1.setEnabled(true);
        }
    }
    
    /**
     * Usado por: mostrarTablas y mostrarCampos
     * Definicion: Metodo que genera un array de tipo String a partir de un ArrayList
     * @param lista
     * @return 
     */
    private String[] cambiarArrayString(ArrayList<String> lista){
        //Creamos el array con el mismo tamaño que la lista del parametro
        String[] listData = new String[lista.size()];
        //Pasamos todos los Strings del la lista al array
        for (int i = 0; i < lista.size(); i++) {
            //Asignamos en el array el String correspondiente de la lista
            listData[i] = lista.get(i);
        }
        //Regresamos el array obttenido
        return listData;
    }
    
    /**
     * Usado por: restablecer
     * Definicion: Metodo que devuelve si una tabla tiene o no respaldo
     * @param tabla
     * @return 
     */
    private boolean tieneRespaldo(String tabla){
        //Almacenara si la tabla tiene o no respaldo
        boolean respaldo = false;
        
        //Definir la consulta para obtener las tablas
        String sql = "show tables";
        
        try {
            //Obtener la conexion y ejecutar la consulta
            Connection con = conexion.getConexion();
            Statement comando = con.createStatement();
            ResultSet registro = comando.executeQuery(sql);
            //Mientras el resultado tenga registros
            while (registro.next()){
                //Obtenemos el nombre de cada tabla
                String r = registro.getString("Tables_in_" + base);
                //En caso de que la tabla sea respaldo
                if(r.equalsIgnoreCase(tabla + Variables.NAME_STRING_END_SUPPORT)){
                    respaldo = true;
                    break;
                }
            }
            
        //En caso de no ejecutar la consulta
        } catch (SQLException ex) {
            JOptionPane.showMessageDialog(
                    this, 
                    "Error al buscar respaldo\n" + ex.toString(), 
                    Variables.MSG_TITLE_ERROR_PADRON, 
                    JOptionPane.ERROR_MESSAGE
            );
        }
        
        //Regresamos si la tabla tiene o no respaldo
        return respaldo;
    }
    
    /**
     * Usado por: existeClaveProceso
     * Definicion: Metodo que determina si un campo contiene la clave catastral
     * @param universo
     * @param campo
     * @return 
     */
    private boolean existeClave(int universo, String campo){
        //Verificara si existe la clave catastral
        boolean existe = false;
        
        //Definimos la consulta para obtener el total de registros con un contenido de 16 digitos
        String sql = ""
                + "select count(*) as total "
                + "from " + tabla 
                + " where length(" + campo + ") = 16";
        
        //Almacenara la cantidad de registros obtenidos en la consulta
        int cantidad = 0;
        
        try {
            //Obtenemos la conexion y ejecutamos la consulta
            Connection con = conexion.getConexion();
            Statement comando = con.createStatement();
            ResultSet registro = comando.executeQuery(sql);
            
            //En caso de que existan registros
            if(registro.next()){
                //Obtener el total de registros con las caracteristicas deseadas
                cantidad = registro.getInt("total");
            }
            
            //En caso de que la cantidad sea la misma que el total de registros de la tabla
            if(cantidad == universo){
                //La clave existe pues en la clave todos los registros deben ser de 16 digitos
                existe = true;
            }
            
        //En caso de no poder obtener el total de registros de un campo
        } catch(SQLException e) {
            JOptionPane.showMessageDialog(
                    this, 
                    "Error al comparar campos\n" + e.toString(), 
                    Variables.MSG_TITLE_ERROR_PADRON, 
                    JOptionPane.ERROR_MESSAGE
            );
        }
        //Regresamos si es o no el campo la clave catastral
        return existe;
    }
    
    /**
     * Usado por: WorkerExisteClave
     * Definicion: Metodo que determina si una tabla contiene la clave catastral
     * @return 
     */
    private boolean existeClaveProceso(){
        //Almacenara el nombre del campo de la clave catastral
        nombre_campo = "";
        
        //Obtener el universo de la tabla
        int universo = obtenerUniverso();
        
        //Analisar cada campo para verificar si es la clave catastral
        for (int i = 0; i < listaCampos.size(); i++) {
            //Determinar si el campo es de la clave catastral
            existe_clave = existeClave(universo, listaCampos.get(i));
            
            //En caso de encontrar un campo con la clave catastral
            if(existe_clave){
                //Obtener el nombre del campo
                nombre_campo = listaCampos.get(i);
                //Terminar el ciclo
                break;
            }
        }
        //Devolver si existe o no la clave en la tabla
        return existe_clave;
        
    }
    
    /**
     * Usado por: aceptar, existeClaveProceso
     * Definicion: Metodo que obtiene el total de registros de una tabla
     * @return 
     */
    private int obtenerUniverso(){
        //Definir la variable que almacenara el universo de la tabla
        int universo = 0;
        
        //Definir la consulta para obtener el universo
        String sql = ""
                + "select count(*) as total "
                + "from " + tabla;
        
        try {
            //Obtener la conexion y ejecutar la consulta
            Connection con = conexion.getConexion();
            Statement comando = con.createStatement();
            ResultSet registro = comando.executeQuery(sql);
            
            //En caso de haber registros
            if (registro.next()) {
                //Obtener el total de registros
                universo = registro.getInt("total");
            }
            
        //En caso de no poder realizar la consulta
        } catch (SQLException e) {
            JOptionPane.showMessageDialog(
                    this, 
                    "Error al obtener universo\n" + e.toString(), 
                    Variables.MSG_TITLE_ERROR_PADRON, 
                    JOptionPane.ERROR_MESSAGE
            );
        }
        
        return universo;
    }
    
    /**
     * Usado por: WorkerRestablecer
     * Definicion: Metodo que elimina la tabla seleccionada y copia el respaldo con el nombre de la anterior
     * @param seleccion: Tabla seleccionada
     */
    private void restablecerProceso(String seleccion){
        try {
            //Obtenemos la conexion
            Connection con = conexion.getConexion();
            Statement comando = con.createStatement();
            //Almacenara las consultas que se ejecutaran
            String sql;
            //Almacenara el resultado de la ejecucion de la consulta
            int actualizacion;
            
            //Eliminar la tabla que se selecciono
            sql = "drop table " + seleccion;
            actualizacion = comando.executeUpdate(sql);
            
            //Crear una nueva tabla con el mismo nombre de la que se elimino, pero con la informacion del respaldo
            sql = ""
                    + "create table " + seleccion 
                    + " select * from " + seleccion + "_respaldo_apc";
            actualizacion = comando.executeUpdate(sql);
            
            //Deshabilitamos el boton de aceptar, en caso de que pase de mostrar campos a tablas
            jButton1.setEnabled(false);
            mostrarTablas();
            
                        
            //Mostrar mensaje de confirmacion
            JOptionPane.showMessageDialog(
                    this, 
                    "Se ha recuperado la tabla " + seleccion + "\n a su formato original", 
                    Variables.MSG_TITLE_NORMAL_PADRON, 
                    JOptionPane.INFORMATION_MESSAGE
            );
                        
        //En caso de que no se puedan ejecutar las consultas
        } catch (SQLException ex) {
            JOptionPane.showMessageDialog(
                    this, 
                    "Error al restablecer la tabla\n" + ex.toString(), 
                    Variables.MSG_TITLE_ERROR_PADRON, 
                    JOptionPane.ERROR_MESSAGE
            );
        }
    }
    
    
    /***************************************************************************
     * METODOS USADOS POR LOS LISTENERS
     ***************************************************************************
     */
    
    
    /**
     * Usado por: Boton salir e Item del menu para salir
     * Definicion: Metodo que termina la ejecucion de la aplicacion
     */
    private void salir() {
        System.exit(0);
    }
    
    /**
     * Usado por: Item del menu para cambiar las credenciales
     * Definicion: Metodo que permite ir a la ventana de logeo
     */
    private void cambiarCredenciales() {
        //Mostrar la ventana de logeo para MySQL
        LoginMySQL loginmysql = new LoginMySQL();
        loginmysql.show();
        this.dispose();
    }
    
    /**
     * Usado por: Boton de restablecer e Item del menu para restablecer
     * Definicion: Metodo que permite restablecer la tabla seleccionada
     */
    private void restablecer() {
        //Obtenemos la tabla seleccionada
        String seleccion = jList2.getSelectedValue();
        
        //En  caso de que no haya seleccionado ninguna
        if(seleccion == null){
            JOptionPane.showMessageDialog(
                    this, 
                    "Debes seleccionar una tabla para trabajar", 
                    Variables.MSG_TITLE_ERROR_PADRON, 
                    JOptionPane.ERROR_MESSAGE
            );
        } else {
            //En caso de que no exista respaldo de la tabla seleccionada
            if(!tieneRespaldo(seleccion)){
                JOptionPane.showMessageDialog(
                        this, 
                        "Aun no existe un respaldo de la tabla\nDebe realizar el proceso de generar la clave", 
                        Variables.MSG_TITLE_NORMAL_PADRON, 
                        JOptionPane.INFORMATION_MESSAGE
                );
            } else {
                //Solicitar al usuario si desea o no continuar
                int i = JOptionPane.showConfirmDialog(
                        this, 
                        "¿Deseas restablecer completamente\n la tabla " + seleccion + "?", 
                        Variables.MSG_TITLE_NORMAL_PADRON, 
                        JOptionPane.YES_NO_OPTION
                );
                //En caso de que desee continuar
                if(i == JOptionPane.YES_OPTION){
                    //Realizar el reestablecimiento
                    WorkerRestablecer worker = new WorkerRestablecer(seleccion);
                    worker.execute();
                }
            }
        }
    }
    
    /**
     * Usado por: Boton aceptar
     * Definicion: Metodo que continua el proceso con la tabla seleccionada
     */
    private void aceptar(){
        //Obtener el universo
        int universo = obtenerUniverso();
        
        //En caso de que la tabla no tenga registros
        if(universo == 0){
            JOptionPane.showMessageDialog(
                    this, 
                    "No es posible realizar ninguna\naccion, la tabla esta vacia", 
                    Variables.MSG_TITLE_NORMAL_PADRON, 
                    JOptionPane.INFORMATION_MESSAGE
            );
        } else {
            //DETERMINAR SI EXISTE LA CLAVE CATASTRAL EN LA TABLA
            
            //Almacenaran los mensajes personalizados
            String msn_1;
            String msn_2;
            
            //Ejecutamos el proceso de existeclave
            WorkerExisteClave worker = new WorkerExisteClave();
            worker.execute();
            try {
                //Obtenemos si la tabla tiene o no clave catastral
                existe_clave = worker.get();
            } catch (InterruptedException | ExecutionException ex) {}
            
            //En caso de que la tabla ya tenga clave catastral generar los mensajes correspondientes
            if(existe_clave){
                msn_1 = "La tabla ya cuenta con la clave catastral" + "\nNombre Campo: " + nombre_campo;
                msn_2 = "¿Desea continuar con esta tabla\n para mostrar la informacion?";
            } else {
                msn_1 = "La tabla aun no cuenta con clave catastral";
                msn_2 = "¿Desea continuar con esta tabla\n para generar la clave catastral?";
            }
            
            //Mostrar el mensaje de notificacion de si la tabla ya cuenta o no con la clave catastral
            JOptionPane.showMessageDialog(
                    this, 
                    msn_1, 
                    Variables.MSG_TITLE_NORMAL_PADRON, 
                    JOptionPane.INFORMATION_MESSAGE
            );
            
            //Mostrar el mesaje de confirmacion para preguntar si desea continuar
            int confirm = JOptionPane.showConfirmDialog(
                    this, 
                    msn_2, 
                    Variables.MSG_TITLE_NORMAL_PADRON, 
                    JOptionPane.YES_NO_OPTION
            );
            
            //En caso de que si desee continuar mostrara la ventana correspondiente
            if (confirm == JOptionPane.YES_OPTION) {
                //En caso de que exista la clave catastral
                if(existe_clave){
                    //Mostrar el vizualizador
                    Visualizador visualizador = new Visualizador(usuario, password, base, tabla);            
                    visualizador.show();
                    this.dispose();
                    
                //En caso de que no exista la clave catastral
                } else {
                    //Pasar a la ventana para generarla
                    Generar generar = new Generar(usuario, password, base, tabla);
                    generar.show();
                    this.dispose();
                }   
            }
        }
    }
    
    
    /***************************************************************************
     * SWING WORKERS PARA LA IMAGEN DE CARGANDO
     * *************************************************************************
     */
    
    
    /**
     * Usado por: restablecer
     * Definicion: Clase que mostrara la ventana de cargando en el proceso de restablecer
     */
    class WorkerRestablecer extends SwingWorker<Double, Void>{
        //Ventana que mostrara el gif de cargando
        Cargando cargando;
        //Almacenara la tabla seleccionada
        String seleccion;

        public WorkerRestablecer(String seleccion) {
            this.seleccion = seleccion;
            cargando  = new Cargando(null, false);
        }
        
        @Override
        protected Double doInBackground() throws Exception {
            cargando.show();
            restablecerProceso(seleccion);
            return 0.0;
        }

        @Override
        protected void done() {
            cargando.dispose();
        }
    }
    
    /**
     * Usado por: aceptar
     * Definicion: Clase que mostrara la ventana de cargando en el proceso de aceptar
     */
    class WorkerExisteClave extends SwingWorker<Boolean, Void> {
        //Ventana que mostrar el gif de cargando
        Cargando cargando;
        //Almacenara si existe o no la clave en la tabla seleccionada
        boolean existe;

        public WorkerExisteClave() {
            cargando  = new Cargando(null, false);
        }
        
        @Override
        protected Boolean doInBackground() throws Exception {
            cargando.show();
            existe = existeClaveProceso();
            return existe;
        }

        @Override
        protected void done() {
            cargando.dispose();
        }
    }
}
